# **Лабораторная работа №9. Динамическое программирование**

> **Цель работы**: Понять принцип динамического программирования (ДП), научиться решать задачи с перекрывающимися подзадачами и оптимальной подструктурой, реализовать алгоритмы для задач о рюкзаке и наибольшей общей подпоследовательности.

---

## **Теория**

В главе 9 книги *"Грокаем алгоритмы"* вводится **динамическое программирование** — метод решения сложных задач путём разбиения на более простые **перекрывающиеся подзадачи**, решения каждого подзадачи **один раз** и сохранения результата (мемоизация или табуляция).

### Основные идеи:
- **Оптимальная подструктура**: оптимальное решение задачи содержит оптимальные решения подзадач.
- **Перекрывающиеся подзадачи**: одни и те же подзадачи встречаются многократно.
- **Подход "снизу вверх" (табуляция)**: решаем сначала маленькие задачи, затем используем их для больших.

### Примеры задач:
1. **Задача о рюкзаке (knapsack problem)** — выбрать предметы с максимальной стоимостью при ограничении по весу.
2. **Наибольшая общая подпоследовательность (LCS)** — найти самую длинную последовательность символов, встречающуюся в двух строках.

---

## **Практическая часть**

### 1. Создайте рабочий файл
- Создайте папку `lab9_dynamic`.
- Внутри — файл `dynamic_programming.py`.
- Откройте его в редакторе.

### 2. Задача о рюкзаке: подготовка данных
Даны предметы с весом и стоимостью:

```python
items = [
    {"name": "Гитара", "weight": 1, "value": 1500},
    {"name": "Магнитофон", "weight": 4, "value": 3000},
    {"name": "Ноутбук", "weight": 3, "value": 2000}
]
capacity = 4  # максимальный вес рюкзака
```

### 3. Создайте таблицу ДП
Создадим двумерный список `dp`, где:
- Строки — предметы (включая "ничего").
- Столбцы — возможные веса от 0 до `capacity`.

```python
n = len(items)
dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]
```

### 4. Заполните таблицу
Для каждого предмета и каждого возможного веса:
- Если предмет **не помещается**, берём значение сверху.
- Иначе — максимум между:
  - значением сверху (не брать),
  - стоимостью предмета + значение на оставшийся вес.

```python
for i in range(1, n + 1):
    weight = items[i-1]["weight"]
    value = items[i-1]["value"]
    for w in range(capacity + 1):
        if weight > w:
            dp[i][w] = dp[i-1][w]  # не можем взять
        else:
            dp[i][w] = max(
                dp[i-1][w],  # не берём
                dp[i-1][w - weight] + value  # берём
            )
```

### 5. Выведите таблицу
```python
print("Таблица DP:")
print("Вес:", end=" ")
for w in range(capacity + 1):
    print(f"{w:4}", end="")
print()
for i in range(n + 1):
    print(f"{items[i-1]['name'] if i > 0 else '---':5}", end=" ")
    for w in range(capacity + 1):
        print(f"{dp[i][w]:4}", end="")
    print()
```

### 6. Найдите оптимальную стоимость
```python
max_value = dp[n][capacity]
print(f"Максимальная стоимость: {max_value}")
```

### 7. Восстановите выбранные предметы
```python
chosen_items = []
w = capacity
for i in range(n, 0, -1):
    if dp[i][w] != dp[i-1][w]:
        chosen_items.append(items[i-1]["name"])
        w -= items[i-1]["weight"]

print("Выбранные предметы:", chosen_items)
```

### 8. Задача LCS: наибольшая общая подпоследовательность
Даны две строки:
```python
str1 = "BDCABA"
str2 = "ABCBDAB"
```

Создайте таблицу `lcs`:
```python
m, n = len(str1), len(str2)
lcs = [[0] * (n + 1) for _ in range(m + 1)]
```

Заполните:
```python
for i in range(1, m + 1):
    for j in range(1, n + 1):
        if str1[i-1] == str2[j-1]:
            lcs[i][j] = lcs[i-1][j-1] + 1
        else:
            lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1])
```

Выведите длину LCS:
```python
print("Длина LCS:", lcs[m][n])  # 4 (например, "BCBA")
```

---

## **Самостоятельная часть**

### 1. Рюкзак с новыми предметами
Добавьте новый предмет: `{"name": "Фонарик", "weight": 1, "value": 200}`.  
Обновите данные и пересчитайте таблицу.  
Как изменился результат?

### 2. Восстановите саму LCS
Напишите функцию `get_lcs(str1, str2, lcs_table)`, которая:
- Принимает строки и заполненную таблицу.
- Восстанавливает **саму подпоследовательность**, двигаясь снизу вправо.

Подсказка:
- Начните с `i = len(str1)`, `j = len(str2)`.
- Если символы равны — добавьте символ и идите по диагонали.
- Иначе — идите к большему из соседей.

Тест:
```python
lcs_str = get_lcs(str1, str2, lcs)
print("LCS:", lcs_str)  # например, "BCBA"
```

---

## **Контрольные вопросы** (ответы устно)

1. В чём разница между динамическим программированием и жадным алгоритмом? Почему ДП даёт точное решение в задаче о рюкзаке?  
2. Что такое "оптимальная подструктура" и "перекрывающиеся подзадачи"? Приведите примеры из этой лабораторной.

---

## **Слепая печать**
1. Пройдите два урока слепой печати на [Python](https://stamina-online.com/ru/workout/programming/15)

---

## **Критерии оценивания**

| Часть работы              | Оценка | Комментарий |
|--------------------------|--------|-------------|
| Практическая часть       | 3      | Все шаги выполнены, таблицы построены корректно |
| Слепая печать            | 4      | Подтверждено выполнение |
| Самостоятельная часть    | 5      | Задачи решены, особенно восстановление LCS — показывает глубокое понимание |
