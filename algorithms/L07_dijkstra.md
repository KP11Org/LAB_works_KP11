# **Лабораторная работа №7. Алгоритм Дейкстры**

> **Цель работы**: Изучить алгоритм Дейкстры — метод поиска кратчайшего пути в **взвешенных графах без отрицательных рёбер**, научиться представлять граф с весами, реализовать алгоритм шаг за шагом, понять разницу между BFS и Дейкстрой.

---

## **Теория**

В главе 7 книги *"Грокаем алгоритмы"* рассматривается **алгоритм Дейкстры** — алгоритм для нахождения кратчайшего пути от начальной вершины ко всем остальным в **взвешенном графе**, при условии, что **веса рёбер неотрицательные**.

### Основные шаги:
1. Найти узел с наименьшей стоимостью среди ещё не обработанных.
2. Обновить стоимости соседей этого узла.
3. Повторять, пока все узлы не будут обработаны.
4. Использовать **таблицу родителей** для восстановления пути.

### Структуры данных:
- **Граф** — словарь словарей: `graph['A']['B'] = 5` (путь из A в B стоит 5).
- **Стоимости** — минимальная стоимость до каждого узла (сначала ∞, кроме стартового).
- **Родители** — отслеживают, откуда пришли в каждый узел.
- **Множество обработанных узлов** — чтобы не пересчитывать.

### Временная сложность:
- Без оптимизации: **O(V²)**.
- С кучей (priority queue): **O((V + E) log V)**.

⚠️ **Не работает с отрицательными весами** — для этого нужен алгоритм Беллмана–Форда.

---

## **Практическая часть**

### 1. Создайте рабочий файл
- Создайте папку `lab7_dijkstra`.
- Внутри — файл `dijkstra.py`.
- Откройте его в редакторе.

### 2. Представьте взвешенный граф
Создадим граф дорог между городами:

```python
graph = {
    'Дом': {'Почта': 5, 'Кинотеатр': 2},
    'Почта': {'Дом': 5, 'Кинотеатр': 1, 'Работа': 4},
    'Кинотеатр': {'Дом': 2, 'Почта': 1, 'Работа': 8, 'Парк': 10},
    'Работа': {'Почта': 4, 'Кинотеатр': 8, 'Парк': 3},
    'Парк': {'Кинотеатр': 10, 'Работа': 3}
}
```

### 3. Инициализируйте таблицы стоимостей и родителей
```python
infinity = float('inf')

# Стоимости от стартовой точки
costs = {
    'Почта': 5,
    'Кинотеатр': 2,
    'Работа': infinity,
    'Парк': infinity
}

# Родители для восстановления пути
parents = {
    'Почта': 'Дом',
    'Кинотеатр': 'Дом',
    'Работа': None,
    'Парк': None
}

processed = []  # уже обработанные узлы
```

### 4. Найдите узел с наименьшей стоимостью
Напишите вспомогательную функцию:

```python
def find_lowest_cost_node(costs, processed):
    lowest_cost = float('inf')
    lowest_node = None
    for node in costs:
        cost = costs[node]
        if cost < lowest_cost and node not in processed:
            lowest_cost = cost
            lowest_node = node
    return lowest_node
```

### 5. Реализуйте алгоритм Дейкстры
```python
def dijkstra(graph, costs, parents, start):
    processed = []
    node = find_lowest_cost_node(costs, processed)

    while node is not None:
        cost = costs[node]
        neighbors = graph[node]
        for neighbor in neighbors:
            new_cost = cost + neighbors[neighbor]
            if new_cost < costs[neighbor]:
                costs[neighbor] = new_cost
                parents[neighbor] = node
        processed.append(node)
        node = find_lowest_cost_node(costs, processed)
```

### 6. Запустите алгоритм и выведите результаты
```python
dijkstra(graph, costs, parents, 'Дом')

print("Стоимости:")
for node, cost in costs.items():
    print(f"{node}: {cost}")

print("\nРодители:")
for child, parent in parents.items():
    print(f"{child} ← {parent}")
```

### 7. Восстановите путь к целевому узлу
Напишите функцию для восстановления пути:

```python
def get_path(parents, start, end):
    path = []
    current = end
    while current is not None:
        path.append(current)
        if current == start:
            break
        current = parents.get(current)
    else:
        return None  # путь не существует
    return list(reversed(path))

path = get_path(parents, 'Дом', 'Парк')
print("Путь:", " → ".join(path))  # Дом → Кинотеатр → Почта → Работа → Парк?
```

> ⚠️ Проверьте: правильный ли путь? Может быть короче?

### 8. Проверьте корректность
Сравните с ручным расчётом:
- `Дом → Кинотеатр (2)` → `Почта (1)` → `Работа (4)` → `Парк (3)` = 2+1+4+3 = 10
- `Дом → Почта (5)` → `Работа (4)` → `Парк (3)` = 5+4+3 = 12
- `Дом → Кинотеатр (2)` → `Работа (8)` → `Парк (3)` = 2+8+3 = 13

Наименьший: **10** — значит, путь должен быть через Кинотеатр → Почта → Работа → Парк.

---

## **Самостоятельная часть**

### 1. Модифицируйте граф и найдите новый путь
Измените вес:
```python
graph['Кинотеатр']['Работа'] = 2  # стало дешевле
```
Пересчитайте стоимости и родителей (не забудьте сбросить `costs` и `parents`).  
Найдите новый кратчайший путь до `Парк`.  
Сравните результат.

### 2. Обобщённая функция Дейкстры
Напишите функцию `dijkstra_full(graph, start, end)`, которая:
- Принимает граф, начальный и конечный узлы.
- Возвращает кортеж: `(кратчайшее расстояние, путь)`.

Подсказка: используйте копии `costs` и `parents`, чтобы не портить глобальные данные.

Пример:
```python
dist, path = dijkstra_full(graph, 'Дом', 'Парк')
print(f"Расстояние: {dist}, Путь: {' → '.join(path)}")
```

---

## **Контрольные вопросы** (ответы устно)

1. Почему алгоритм Дейкстры не работает с отрицательными весами? Приведите пример.  
2. Чем алгоритм Дейкстры отличается от поиска в ширину (BFS)? В каких случаях каждый из них применяется?

---

## **Слепая печать**
1. Пройдите два урока слепой печати на [Python](https://stamina-online.com/ru/workout/programming/15)

---

## **Критерии оценивания**

| Часть работы              | Оценка | Комментарий |
|--------------------------|--------|-------------|
| Практическая часть       | 3      | Все шаги выполнены, алгоритм работает корректно |
| Слепая печать            | 4      | Подтверждено выполнение |
| Самостоятельная часть    | 5      | Задачи решены, особенно обобщённая функция — показывает глубокое понимание |
