# **Лабораторная работа №1. Знакомство с алгоритмами**

> **Цель работы**: Понять, что такое алгоритм, изучить базовые понятия: последовательность шагов, эффективность, сравнение подходов (линейный и бинарный поиск), научиться оценивать время выполнения алгоритмов.

---

## **Теория**

Алгоритм — это чётко определённая последовательность действий для решения поставленной задачи. Алгоритмы используются повсеместно: от поиска слова в словаре до маршрутизации данных в интернете.

В главе 1 рассматриваются:
- Что такое алгоритм.
- Примеры: линейный и бинарный поиск.
- Понятие **временной сложности** — сколько шагов выполняет алгоритм в зависимости от размера входных данных.
- Введение в **О-большое** — способ описания верхней границы времени выполнения алгоритма.

**Линейный поиск** — проверяет каждый элемент по очереди. Время выполнения: **O(n)**.  
**Бинарный поиск** — работает только с отсортированными данными, каждый раз сокращая область поиска вдвое. Время выполнения: **O(log n)**.

---

## **Практическая часть**

Выполните следующие шаги, внимательно следуя инструкциям.

### 1. Создайте Python-файл и настройте окружение
- Создайте папку `lab1_algorithms`.
- Внутри создайте файл `search_algorithms.py`.
- Откройте файл в редакторе (например, VS Code, PyCharm или IDLE).

### 2. Реализуйте линейный поиск
Напишите функцию `linear_search(arr, target)`, которая:
- Принимает список `arr` и значение `target`.
- Возвращает индекс элемента, если он найден, иначе — `-1`.

```python
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1
```

### 3. Реализуйте бинарный поиск (итеративно)
Напишите функцию `binary_search(arr, target)`, которая:
- Работает только с **отсортированным** списком.
- Использует два указателя: `low` и `high`.
- Пока `low <= high`, вычисляет `mid` и сравнивает `arr[mid]` с `target`.

```python
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2
        guess = arr[mid]
        if guess == target:
            return mid
        elif guess > target:
            high = mid - 1
        else:
            low = mid + 1
    return -1
```

### 4. Протестируйте оба алгоритма
Добавьте в конец файла код для тестирования:

```python
# Тестовые данные
data = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
target = 7

print("Линейный поиск:", linear_search(data, target))  # Ожидается: 3
print("Бинарный поиск:", binary_search(data, target))  # Ожидается: 3
```

Запустите программу. Убедитесь, что оба поиска возвращают правильный индекс.

### 5. Сравните количество шагов
Модифицируйте функции, чтобы они **считали количество шагов** (итераций):

```python
def linear_search_steps(arr, target):
    steps = 0
    for i in range(len(arr)):
        steps += 1
        if arr[i] == target:
            return i, steps
    return -1, steps

def binary_search_steps(arr, target):
    low = 0
    high = len(arr) - 1
    steps = 0

    while low <= high:
        steps += 1
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid, steps
        elif arr[mid] > target:
            high = mid - 1
        else:
            low = mid + 1
    return -1, steps
```

Протестируйте с `target = 19`:

```python
print("Линейный (индекс, шаги):", linear_search_steps(data, 19))
print("Бинарный (индекс, шаги):", binary_search_steps(data, 19))
```

**Ожидание**: Линейный — 10 шагов, Бинарный — 4 шага.

---

## **Самостоятельная часть**

Решите следующие задачи самостоятельно и добавьте код в тот же файл.

### 1. Поиск элемента в неотсортированном списке
Дан список: `names = ["Иван", "Мария", "Алексей", "Елена", "Дмитрий"]`.  
Напишите функцию `find_name(names_list, name)`, которая ищет имя и возвращает `True`, если найдено, иначе `False`.  
Используйте линейный поиск.

### 2. Анализ эффективности
Напишите код, который:
- Генерирует отсортированный список из 1000 чисел: `list(range(1, 1001))`.
- Ищет число `999` с помощью обоих алгоритмов (с подсчётом шагов).
- Выводит результат и делает вывод: какой алгоритм эффективнее и почему.

---

## **Контрольные вопросы** (ответы устно)

1. В чём разница между линейным и бинарным поиском? При каких условиях можно использовать бинарный поиск?  
2. Что означает запись **O(n)** и **O(log n)**? Какой из них быстрее при больших n?

---

## **Слепая печать**
1. Пройдите два урока слепой печати на [Python](https://stamina-online.com/ru/workout/programming/15)

---

## **Критерии оценивания**

| Часть работы              | Оценка | Комментарий |
|--------------------------|------------|-------------|
| Практическая часть       | 3          | Все шаги выполнены, код работает |
| Слепая печать            | 4          | Выполнено |
| Самостоятельная часть    | 5          | Задачи решены корректно, с пояснениями |
