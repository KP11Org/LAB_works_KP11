# **Лабораторная работа №6. Поиск в ширину**

> **Цель работы**: Изучить алгоритм **поиска в ширину (Breadth-First Search, BFS)**, понять его применение для поиска кратчайшего пути в невзвешенных графах, научиться реализовывать BFS с использованием очереди, применить его к реальным задачам — например, поиску связи между людьми.

---

## **Теория**

В главе 6 книги *"Грокаем алгоритмы"* рассматривается **поиск в ширину** — алгоритм обхода графа, который исследует все узлы на расстоянии 1 от стартового, затем на расстоянии 2 и т.д.

### Основные понятия:
- **Граф** — структура из **узлов (вершин)** и **рёбер**, представляющих связи.
- **Очередь (queue)** — структура данных "первым пришёл — первым вышел" (FIFO), необходимая для BFS.
- **Кратчайший путь** — в невзвешенном графе BFS находит путь с минимальным количеством рёбер.

### Применение:
- Поиск друзей в соцсетях (например, "друзья друзей").
- Поиск маршрутов.
- Проверка на связность графа.

### Сложность:
- Временная: **O(V + E)**, где V — вершины, E — рёбра.
- Требует хранения посещённых узлов, чтобы избежать зацикливания.

---

## **Практическая часть**

### 1. Создайте рабочий файл
- Создайте папку `lab6_bfs`.
- Внутри — файл `bfs.py`.
- Откройте его в редакторе.

### 2. Представьте граф как словарь
Создадим граф друзей:

```python
graph = {
    'Алиса': ['Боб', 'Карина', 'Дмитрий'],
    'Боб': ['Алиса', 'Елена', 'Фёдор'],
    'Карина': ['Алиса', 'Глеб'],
    'Дмитрий': ['Алиса', 'Марина'],
    'Елена': ['Боб'],
    'Фёдор': ['Боб'],
    'Глеб': ['Карина'],
    'Марина': ['Дмитрий']
}
```

### 3. Реализуйте очередь с помощью `collections.deque`
Импортируйте `deque` для эффективной очереди:

```python
from collections import deque

def bfs(graph, start, target):
    queue = deque([start])
    visited = set()  # чтобы не посещать узлы дважды
    visited.add(start)

    while queue:
        person = queue.popleft()
        print(f"Проверяю: {person}")

        if person == target:
            print(f"Найдено: {target}!")
            return True

        for friend in graph[person]:
            if friend not in visited:
                queue.append(friend)
                visited.add(friend)

    print("Не найдено.")
    return False
```

### 4. Протестируйте BFS
```python
bfs(graph, 'Алиса', 'Глеб')   # Должно найти
bfs(graph, 'Алиса', 'Олег')   # Не существует — вернёт False
```

### 5. Модифицируйте BFS для поиска кратчайшего пути
Теперь найдём **путь**, а не только факт наличия связи.

```python
def bfs_path(graph, start, target):
    queue = deque([(start, [start])])  # (текущий узел, путь до него)
    visited = {start}

    while queue:
        person, path = queue.popleft()

        if person == target:
            print(f"Путь найден: {' → '.join(path)}")
            return path

        for friend in graph[person]:
            if friend not in visited:
                visited.add(friend)
                queue.append((friend, path + [friend]))

    print("Путь не найден.")
    return None
```

Тест:
```python
bfs_path(graph, 'Алиса', 'Глеб')
# Ожидаемый путь: Алиса → Карина → Глеб
```

### 6. Визуализация обхода
Добавьте счётчик уровней (дистанции от старта):

```python
def bfs_with_levels(graph, start):
    queue = deque([(start, 0)])
    visited = {start}
    print(f"Уровень 0: {start}")

    while queue:
        person, level = queue.popleft()

        for friend in graph[person]:
            if friend not in visited:
                visited.add(friend)
                print(f"Уровень {level + 1}: {friend}")
                queue.append((friend, level + 1))
```

Тест:
```python
bfs_with_levels(graph, 'Алиса')
```

### 7. Проверка, есть ли путь до всех
Напишите функцию, которая проверяет, можно ли достичь всех узлов из стартового:

```python
def is_connected_from(graph, start):
    queue = deque([start])
    visited = {start}

    while queue:
        person = queue.popleft()
        for friend in graph[person]:
            if friend not in visited:
                visited.add(friend)
                queue.append(friend)

    # Все ли ключи графа посещены?
    return len(visited) == len(graph)

print("Связан с каждым?", is_connected_from(graph, 'Алиса'))
```

---

## **Самостоятельная часть**

### 1. Найдите всех друзей на заданном уровне
Напишите функцию `friends_at_level(graph, start, level)`, которая возвращает список людей, находящихся **ровно на расстоянии `level`** от `start`.

Пример:
```python
friends_at_level(graph, 'Алиса', 1)  # ['Боб', 'Карина', 'Дмитрий']
friends_at_level(graph, 'Алиса', 2)  # ['Елена', 'Фёдор', 'Глеб', 'Марина']
```

> Подсказка: используйте BFS с отслеживанием уровня.

### 2. Проверка на "шестую степень разделённости"
Реализуйте функцию `is_within_six_degrees(graph, start, target)`, которая возвращает `True`, если `target` достижим из `start` за **6 шагов или меньше**.

> Подсказка: модифицируйте BFS, чтобы останавливаться после 6 уровней.

---

## **Контрольные вопросы** (ответы устно)

1. Почему для BFS используется очередь, а не стек? Что изменится, если использовать стек?  
2. В каких случаях BFS находит кратчайший путь? Почему он не подходит для взвешенных графов?

---

## **Слепая печать**
1. Пройдите два урока слепой печати на [Python](https://stamina-online.com/ru/workout/programming/15)

---

## **Критерии оценивания**

| Часть работы              | Оценка | Комментарий |
|--------------------------|--------|-------------|
| Практическая часть       | 3      | Все шаги выполнены, код работает |
| Слепая печать            | 4      | Подтверждено выполнение |
| Самостоятельная часть    | 5      | Задачи решены, особенно с уровнями и ограничением по шагам — демонстрирует глубокое понимание |
