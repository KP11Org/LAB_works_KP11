# **Лабораторная работа №3. Рекурсия**

> **Цель работы**: Понять концепцию рекурсии, научиться разбивать задачи на подзадачи, реализовать рекурсивные функции (факториал, числа Фибоначчи, сумма массива), освоить базовый и рекурсивный случаи.

---

## **Теория**

В главе 3 книги *"Грокаем алгоритмы"* вводится понятие **рекурсии** — это подход, при котором функция вызывает саму себя для решения меньшей части задачи.

Каждая рекурсивная функция состоит из двух частей:
1. **Базовый случай (base case)** — условие, при котором рекурсия останавливается.
2. **Рекурсивный случай (recursive case)** — вызов функции с изменёнными параметрами, приближающими к базовому случаю.

Пример:  
Вычисление факториала:
- 5! = 5 × 4!
- 4! = 4 × 3!
- ...
- 1! = 1 → **базовый случай**

⚠️ Без базового случая рекурсия будет бесконечной (и приведёт к `RecursionError`).

---

## **Практическая часть**

### 1. Создайте рабочий файл
- Создайте папку `lab3_recursion`.
- Внутри — файл `recursion_practice.py`.
- Откройте его в редакторе.

### 2. Реализуйте рекурсивный факториал
Напишите функцию `factorial(n)`, которая:
- Возвращает 1 при `n == 0` или `n == 1` (базовый случай).
- Иначе возвращает `n * factorial(n - 1)`.

```python
def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)
```

### 3. Протестируйте факториал
Добавьте тесты:

```python
print("0! =", factorial(0))  # 1
print("1! =", factorial(1))  # 1
print("5! =", factorial(5))  # 120
```

Запустите программу. Убедитесь, что всё работает.

### 4. Напишите рекурсивную сумму массива
Создайте функцию `sum_array(arr)`, которая:
- Если массив пуст — возвращает 0 (базовый случай).
- Иначе — возвращает первый элемент + сумму остальных.

```python
def sum_array(arr):
    if not arr:
        return 0
    else:
        return arr[0] + sum_array(arr[1:])
```

> ⚠️ `arr[1:]` создаёт новый список — не самый эффективный способ, но наглядный.

Тест:

```python
print("Сумма [1, 2, 3, 4]:", sum_array([1, 2, 3, 4]))  # 10
print("Сумма []:", sum_array([]))  # 0
```

### 5. Реализуйте счётчик вызовов
Модифицируйте `factorial`, чтобы считать количество вызовов:

```python
def factorial_with_count(n, call_count=0):
    call_count += 1
    print(f"Вызов factorial({n}), глубина: {call_count}")

    if n == 0 or n == 1:
        return 1, call_count
    else:
        result, final_count = factorial_with_count(n - 1, call_count)
        return n * result, final_count
```

Тест:

```python
result, calls = factorial_with_count(5)
print(f"5! = {result}, вызовов: {calls}")  # Ожидается 5 вызовов
```

### 6. Напишите рекурсивный счёт элементов
Функция `count_elements(arr)` возвращает количество элементов в списке без использования `len()`:

```python
def count_elements(arr):
    if not arr:
        return 0
    else:
        return 1 + count_elements(arr[1:])
```

Тест:

```python
print("Кол-во элементов [10,20,30]:", count_elements([10,20,30]))  # 3
```

### 7. Найдите максимальное число рекурсивно
Функция `max_recursive(arr)`:
- Базовый случай: если один элемент — вернуть его.
- Рекурсивно: сравнить первый элемент с максимумом остальных.

```python
def max_recursive(arr):
    if len(arr) == 1:
        return arr[0]
    else:
        sub_max = max_recursive(arr[1:])
        return arr[0] if arr[0] > sub_max else sub_max
```

Тест:

```python
print("Максимум [3, 7, 2, 9, 1]:", max_recursive([3, 7, 2, 9, 1]))  # 9
```

---

## **Самостоятельная часть**

### 1. Числа Фибоначчи рекурсивно
Напишите функцию `fibonacci(n)`, которая возвращает n-е число Фибоначчи:
- F(0) = 0
- F(1) = 1
- F(n) = F(n-1) + F(n-2)

Протестируйте:
- `fibonacci(0)` → 0
- `fibonacci(1)` → 1
- `fibonacci(6)` → 8

> ⚠️ Эта реализация будет медленной при больших n — это нормально для обучения.

### 2. Глубина рекурсии
Попробуйте вызвать `factorial(1000)`. Что произойдёт?  
Затем выполните:

```python
import sys
print("Лимит рекурсии:", sys.getrecursionlimit())
```

Попробуйте увеличить лимит (не рекомендуется, но для эксперимента):

```python
sys.setrecursionlimit(2000)
```

Повторите вызов. Сделайте вывод: почему важно иметь базовый случай и как Python защищает от бесконечной рекурсии?

---

## **Контрольные вопросы** (ответы устно)

1. Что такое базовый случай и зачем он нужен в рекурсии? Приведите пример из этой лабораторной.  
2. Почему рекурсивный способ вычисления чисел Фибоначчи неэффективен? Как можно его улучшить?

---

## **Слепая печать**
1. Пройдите два урока слепой печати на [Python](https://stamina-online.com/ru/workout/programming/15)

---

## **Критерии оценивания**

| Часть работы              | Оценка | Комментарий |
|--------------------------|--------|-------------|
| Практическая часть       | 3      | Все шаги выполнены, код работает |
| Слепая печать            | 4      | Подтверждено выполнение |
| Самостоятельная часть    | 5      | Задачи решены, есть понимание, код читаемый и корректный |
