# **Лабораторная работа №8. Жадные алгоритмы**

> **Цель работы**: Понять принцип работы жадных алгоритмов, научиться применять их к задачам оптимизации, реализовать жадный выбор на примере покрытия множеств, оценить эффективность и ограничения таких алгоритмов.

---

## **Теория**

В главе 8 книги *"Грокаем алгоритмы"* рассматривается подход **жадных алгоритмов** — алгоритмов, которые на каждом шаге выбирают **локально оптимальное решение**, в надежде, что оно приведёт к **глобально оптимальному** результату.

### Пример задачи: **Задача о покрытии множества**
- Дано: множество станций, каждая покрывает определённые штаты.
- Цель: выбрать **минимальное количество станций**, чтобы покрыть **все нужные штаты**.

### Принцип жадного подхода:
1. Пока есть штаты, которые нужно покрыть:
   - Выбрать станцию, которая покрывает **максимальное количество непокрытых штатов**.
   - Добавить её в результат.
   - Удалить покрытые штаты из списка.
2. Повторять, пока все штаты не будут покрыты.

### Преимущества:
- Быстрота: работает за полиномиальное время.
- Простота реализации.

### Недостатки:
- Не всегда даёт **точное** оптимальное решение.
- Но часто даёт **приближённое**, близкое к оптимальному.

---

## **Практическая часть**

### 1. Создайте рабочий файл
- Создайте папку `lab8_greedy`.
- Внутри — файл `greedy_algorithm.py`.
- Откройте его в редакторе.

### 2. Определите данные задачи
Создадим словарь станций и множества штатов, которые они покрывают:

```python
stations = {
    'kone': {'id', 'nv', 'ut'},
    'ktwo': {'wa', 'id', 'mt'},
    'kthree': {'or', 'nv', 'ca'},
    'kfour': {'nv', 'ut'},
    'kfive': {'ca', 'az'}
}

# Штаты, которые нужно покрыть
states_needed = {'id', 'nv', 'ut', 'wa', 'mt', 'or', 'ca', 'az'}
```

### 3. Реализуйте жадный алгоритм
```python
final_stations = set()

while states_needed:
    # Находим станцию, покрывающую максимум непокрытых штатов
    best_station = None
    states_covered = set()

    for station, states_for_station in stations.items():
        covered = states_needed & states_for_station  # пересечение
        if len(covered) > len(states_covered):
            best_station = station
            states_covered = covered

    # Добавляем лучшую станцию
    final_stations.add(best_station)
    # Удаляем покрытые штаты
    states_needed -= states_covered

    # Удаляем станцию из рассмотрения (необязательно, но чисто)
    del stations[best_station]
```

### 4. Выведите результат
```python
print("Оптимальные станции:", final_stations)
# Примерный результат: {'kone', 'ktwo', 'kthree', 'kfive'}
```

### 5. Добавьте отладочный вывод
Модифицируйте цикл, чтобы видеть, что происходит на каждом шаге:

```python
step = 1
while states_needed:
    best_station = None
    states_covered = set()

    for station, states_for_station in stations.items():
        covered = states_needed & states_for_station
        if len(covered) > len(states_covered):
            best_station = station
            states_covered = covered

    final_stations.add(best_station)
    states_needed -= states_covered
    del stations[best_station]

    print(f"Шаг {step}: выбрана станция {best_station}, покрыты: {states_covered}")
    print(f"Осталось покрыть: {states_needed}")
    step += 1
```

### 6. Проверьте полноту покрытия
После завершения алгоритма проверьте, все ли штаты были покрыты:

```python
all_covered = set()
for station in final_stations:
    all_covered |= stations_original[station]  # объединяем все покрытия

if all_covered >= states_needed_original:
    print("✅ Все штаты покрыты!")
else:
    print("❌ Не все штаты покрыты.")
```

> ⚠️ Сохраните оригинальные данные до запуска:
```python
states_needed_original = {'id', 'nv', 'ut', 'wa', 'mt', 'or', 'ca', 'az'}
stations_original = {
    'kone': {'id', 'nv', 'ut'},
    'ktwo': {'wa', 'id', 'mt'},
    'kthree': {'or', 'nv', 'ca'},
    'kfour': {'nv', 'ut'},
    'kfive': {'ca', 'az'}
}
```

### 7. Подсчитайте количество выбранных станций
```python
print(f"Всего станций выбрано: {len(final_stations)}")
```

---

## **Самостоятельная часть**

### 1. Задача о сдаче (жадный выбор монет)
Напишите функцию `make_change(amount, coins)`, которая:
- Принимает сумму (например, 37) и список номиналов монет (например, `[25, 10, 5, 1]`).
- Использует жадный подход: на каждом шаге берёт **наибольшую возможную монету**.
- Возвращает словарь: `{25: 1, 10: 1, 1: 2}` для 37.

> ⚠️ Это **не всегда оптимально** при произвольных номиналах, но работает для стандартных (американских).

Тест:
```python
print(make_change(37, [25, 10, 5, 1]))  # 25+10+1+1 → {25:1, 10:1, 1:2}
```

### 2. Анализ ограничений
Попробуйте:
```python
make_change(30, [25, 20, 10, 5, 1])
```
Жадный алгоритм выберет: `25 + 5×1` → 6 монет.  
Но оптимально: `20 + 10` → 2 монеты.

Сделайте вывод: **в каких случаях жадный алгоритм не даёт оптимального решения?**

---

## **Контрольные вопросы** (ответы устно)

1. В чём суть жадного подхода? Почему он не всегда даёт оптимальный результат?  
2. Какие задачи можно решать с помощью жадных алгоритмов, кроме покрытия множеств?

---

## **Слепая печать**
1. Пройдите два урока слепой печати на [Python](https://stamina-online.com/ru/workout/programming/15)

---

## **Критерии оценивания**

| Часть работы              | Оценка | Комментарий |
|--------------------------|--------|-------------|
| Практическая часть       | 3      | Все шаги выполнены, алгоритм работает |
| Слепая печать            | 4      | Подтверждено выполнение |
| Самостоятельная часть    | 5      | Задачи решены, особенно анализ неоптимальности — показывает понимание границ метода |
