# **Лабораторная работа №2. Сортировка выбором**

> **Цель работы**: Изучить алгоритм сортировки выбором, понять его принцип работы, реализовать его на Python, оценить временную сложность и сравнить с другими подходами.

---

## **Теория**

В главе 2 книги *"Грокаем алгоритмы"* рассматривается алгоритм **сортировки выбором (selection sort)** — простой, но не самый эффективный способ упорядочивания данных.

**Принцип работы**:
1. Находим наименьший элемент в неотсортированной части массива.
2. Помещаем его в начало (в конец уже отсортированной части).
3. Повторяем для оставшейся части массива.

Алгоритм использует **два массива** (в воображении): отсортированный и неотсортированный. На практике мы работаем с одним массивом, но "мысленно" разделяем его.

- **Временная сложность**: O(n²) — из-за вложенных циклов.
- **Преимущество**: Простота понимания.
- **Недостаток**: Неэффективен на больших данных.

---

## **Практическая часть**

Выполните следующие шаги по порядку.

### 1. Создайте файл для работы
- В папке `lab2_selection_sort` создайте файл `selection_sort.py`.
- Откройте его в редакторе кода.

### 2. Напишите функцию поиска индекса минимального элемента
Создайте функцию `find_min_index(arr)`, которая возвращает индекс наименьшего элемента в списке.

```python
def find_min_index(arr):
    min_index = 0
    for i in range(1, len(arr)):
        if arr[i] < arr[min_index]:
            min_index = i
    return min_index
```

### 3. Протестируйте функцию
Добавьте тест:

```python
print("Индекс минимума в [5, 2, 8, 1, 9]:", find_min_index([5, 2, 8, 1, 9]))  # Ожидается: 3
```

Запустите — убедитесь, что выводит `3`.

### 4. Реализуйте сортировку выбором
Создайте функцию `selection_sort(arr)`, которая:
- Создаёт новый пустой список `sorted_arr`.
- Пока исходный список не пуст:
  - Находит индекс минимального элемента.
  - Удаляет этот элемент из `arr` и добавляет в `sorted_arr`.

```python
def selection_sort(arr):
    sorted_arr = []
    while arr:
        min_index = find_min_index(arr)
        sorted_arr.append(arr.pop(min_index))
    return sorted_arr
```

> ⚠️ Метод `pop()` удаляет элемент по индексу и возвращает его.

### 5. Протестируйте сортировку
Добавьте код:

```python
data = [64, 25, 12, 22, 11]
print("Исходный массив:", data)
print("Отсортированный:", selection_sort(data.copy()))  # [11, 12, 22, 25, 64]
```

> Используем `.copy()`, чтобы не изменять исходный список.

### 6. Добавьте подсчёт операций
Модифицируйте `find_min_index`, чтобы считать количество сравнений:

```python
def find_min_index_with_count(arr):
    min_index = 0
    comparisons = 0
    for i in range(1, len(arr)):
        comparisons += 1
        if arr[i] < arr[min_index]:
            min_index = i
    return min_index, comparisons
```

Обновите `selection_sort` для подсчёта общего числа сравнений:

```python
def selection_sort_with_stats(arr):
    sorted_arr = []
    total_comparisons = 0
    while arr:
        min_index, comparisons = find_min_index_with_count(arr)
        total_comparisons += comparisons
        sorted_arr.append(arr.pop(min_index))
    return sorted_arr, total_comparisons
```

Тест:

```python
data = [64, 25, 12, 22, 11]
result, comp = selection_sort_with_stats(data.copy())
print("Отсортировано:", result)
print("Всего сравнений:", comp)  # Для n=5: 4+3+2+1 = 10
```

### 7. Сравните с встроенной сортировкой
Добавьте:

```python
data = [64, 25, 12, 22, 11]
print("Python sorted():", sorted(data))
```

Убедитесь, что результаты совпадают.

---

## **Самостоятельная часть**

### 1. Обратная сортировка
Напишите функцию `selection_sort_desc(arr)`, которая сортирует список по **убыванию** (от большего к меньшему).  
Используйте ту же логику, но ищите **максимальный** элемент.

> Подсказка: измените условие в `find_min_index` на `>` и назовите функцию `find_max_index`.

### 2. Анализ сложности
Создайте список из 10 чисел: `list(range(10, 0, -1))` — [10,9,...,1].  
Отсортируйте его с помощью вашего алгоритма и выведите:
- Отсортированный результат.
- Общее количество сравнений.

Сделайте вывод: как растёт число сравнений при увеличении длины массива?  
(Подсказка: это сумма арифметической прогрессии: n-1 + n-2 + ... + 1 = n(n-1)/2)

---

## **Контрольные вопросы** (ответы устно)

1. Почему сортировка выбором имеет сложность O(n²)? Где "прячутся" два уровня вложенности?  
2. В чём разница между сортировкой выбором и использованием встроенной функции `sorted()` в Python?

---

## **Слепая печать**
1. Пройдите два урока слепой печати на [Python](https://stamina-online.com/ru/workout/programming/15)

---

## **Критерии оценивания**

| Часть работы              | Оценка | Комментарий |
|--------------------------|--------|-------------|
| Практическая часть       | 3      | Все шаги выполнены, код работает корректно |
| Слепая печать            | 4      | Выполнено (подтверждение: скриншот или время занятия) |
| Самостоятельная часть    | 5      | Задачи решены, есть пояснения, код чистый и рабочий |
